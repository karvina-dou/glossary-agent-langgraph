Acyclic redundancy check(CRC) is anerror-detecting codecommonly used in digitalnetworksand storage devices to detect accidental changes to digital data.Blocks of data entering these systems get a shortcheck valueattached, based on the remainder of apolynomial divisionof their contents. On retrieval, the calculation is repeated and, in the event the check values do not match, corrective action can be taken against data corruption. CRCs can be used forerror correction(seebitfilters).
CRCs are so called because thecheck(data verification) value is aredundancy(it expands the message without addinginformation) and thealgorithmis based oncycliccodes. CRCs are popular because they are simple to implement in binaryhardware, easy to analyze mathematically, and particularly good at detecting common errors caused bynoisein transmission channels.  Because the check value has a fixed length, thefunctionthat generates it is occasionally used as ahash function.
CRCs are based on the theory ofcyclicerror-correcting codes. The use ofsystematiccyclic codes, which encode messages by adding a fixed-length check value, for the purpose of error detection in communication networks, was first proposed byW. Wesley Petersonin 1961.Cyclic codes are not only simple to implement but have the benefit of being particularly well suited for the detection ofburst errors: contiguous sequences of erroneous data symbols in messages. This is important because burst errors are common transmission errors in manycommunication channels, including magnetic and optical storage devices. Typically ann-bit CRC applied to a data block of arbitrary length will detect any single error burst not longer thannbits, and the fraction of all longer error bursts that it will detect is approximately(1 − 2).
Specification of a CRC code requires definition of a so-calledgenerator polynomial. This polynomial becomes thedivisorin apolynomial long division, which takes the message as thedividendand in which thequotientis discarded and theremainderbecomes the result.  The important caveat is that the polynomialcoefficientsare calculated according to the arithmetic of afinite field, so the addition operation can always be performed bitwise-parallel (there is no carry between digits).
In practice, all commonly used CRCs employ the finite field of two elements,GF(2). The two elements are usually called 0 and 1, comfortably matching computer architecture.
A CRC is called ann-bit CRC when its check value isnbits long. For a givenn, multiple CRCs are possible, each with a different polynomial. Such a polynomial has highest degreen, which means it hasn+ 1terms. In other words, the polynomial has a length ofn+ 1; its encoding requiresn+ 1bits. Note that most polynomial specifications either drop theMSborLSb, since they are always 1. The CRC and associated polynomial typically have a name of the form CRC-n-XXX as in thetablebelow.
The simplest error-detection system, theparity bit, is in fact a 1-bit CRC: it uses the generator polynomialx+ 1(two terms),and has the name CRC-1.
A CRC-enabled device calculates a short, fixed-length binary sequence, known as thecheck valueorCRC, for each block of data to be sent or stored and appends it to the data, forming acodeword.
When a codeword is received or read, the device either compares its check value with one freshly calculated from the data block, or equivalently, performs a CRC on the whole codeword and compares the resulting check value with an expectedresidueconstant.
If the CRC values do not match, then the block contains a data error.
The device may take corrective action, such as rereading the block or requesting that it be sent again. Otherwise, the data is assumed to be error-free (though, with some small probability, it may contain undetected errors; this is inherent in the nature of error-checking).
CRCs are specifically designed to protect against common types of errors on communication channels, where they can provide quick and reasonable assurance of theintegrityof messages delivered. However, they are not suitable for protecting against intentional alteration of data.
Firstly, as there is no authentication, an attacker can edit a message and recompute the CRC without the substitution being detected. When stored alongside the data, CRCs and cryptographic hash functions by themselves do not protect againstintentionalmodification of data. Any application that requires protection against such attacks must use cryptographic authentication mechanisms, such asmessage authentication codesordigital signatures(which are commonly based oncryptographic hashfunctions).
Secondly, unlike cryptographic hash functions, CRC is an easily reversible function, which makes it unsuitable for use in digital signatures.
Thirdly, CRC satisfies a relation similar to that of alinear function(or more accurately, anaffine function):
wherec{\displaystyle c}depends on the length ofx{\displaystyle x}andy{\displaystyle y}. This can be also stated as follows, wherex{\displaystyle x},y{\displaystyle y}andz{\displaystyle z}have the same length
as a result, even if the CRC is encrypted with astream cipherthat usesXORas its combining operation (ormodeofblock cipherwhich effectively turns it into a stream cipher, such as OFB or CFB), both the message and the associated CRC can be manipulated without knowledge of the encryption key; this was one of the well-known design flaws of theWired Equivalent Privacy(WEP) protocol.
To compute ann-bit binary CRC, line the bits representing the input in a row, and position the (n+ 1)-bit pattern representing the CRC's divisor (called a "polynomial") underneath the left end of the row.
In this example, we shall encode 14 bits of message with a 3-bit CRC, with a polynomialx+x+ 1. The polynomial is written in binary as the coefficients; a 3rd-degree polynomial has 4 coefficients (1x+ 0x+ 1x+ 1). In this case, the coefficients are 1, 0, 1 and 1.  The result of the calculation is 3 bits long, which is why it is called a 3-bit CRC. However, you need 4 bits to explicitly state the polynomial.
Start with the message to be encoded:
This is first padded with zeros corresponding to the bit lengthnof the CRC. This is done so that the resulting code word is insystematicform. Here is the first calculation for computing a 3-bit CRC:
The algorithm acts on the bits directly above the divisor in each step.  The result for that iteration is the bitwise XOR of the polynomial divisor with the bits above it.  The bits not above the divisor are simply copied directly below for that step.  The divisor is then shifted right to align with the highest remaining 1 bit in the input, and the process is repeated until the divisor reaches the right-hand end of the input row. Here is the entire calculation:
Since the leftmost divisor bit zeroed every input bit it touched, when this process ends the only bits in the input row that can be nonzero are the n bits at the right-hand end of the row. Thesenbits are the remainder of the division step, and will also be the value of the CRC function (unless the chosen CRC specification calls for some postprocessing).
The validity of a received message can easily be verified by performing the above calculation again, this time with the check value added instead of zeroes. The remainder should equal zero if there are no detectable errors.
The followingPythoncode outlines a function which will return the initial CRC remainder for a chosen input and polynomial, with either 1 or 0 as the initial padding. Note that this code works with string inputs rather than raw numbers:
Mathematical analysis of this division-like process reveals how to select a divisor that guarantees good error-detection properties. In this analysis, the digits of the bit strings are taken as the coefficients of a polynomial in some variablex—coefficients that are elements of the finite fieldGF(2)(the integers modulo 2, i.e. either a zero or a one), instead of more familiar numbers. The set of binary polynomials is a mathematicalring.
The selection of the generator polynomial is the most important part of implementing the CRC algorithm. The polynomial must be chosen to maximize the error-detecting capabilities while minimizing overall collision probabilities.
The most important attribute of the polynomial is its length (largest degree(exponent) +1 of any one term in the polynomial), because of its direct influence on the length of the computed check value.
The most commonly used polynomial lengths are 9 bits (CRC-8), 17 bits (CRC-16), 33 bits (CRC-32), and 65 bits (CRC-64).
A CRC is called ann-bit CRC when its check value isn-bits. For a givenn, multiple CRCs are possible, each with a different polynomial. Such a polynomial has highest degreen, and hencen+ 1terms (the polynomial has a length ofn+ 1). The remainder has lengthn. The CRC has a name of the form CRC-n-XXX.
The design of the CRC polynomial depends on the maximum total length of the block to be protected (data + CRC bits), the desired error protection features, and the type of resources for implementing the CRC, as well as the desired performance. A common misconception is that the "best" CRC polynomials are derived from eitherirreducible polynomialsor irreducible polynomials times the factor1 +x, which adds to the code the ability to detect all errors affecting an odd number of bits.In reality, all the factors described above should enter into the selection of the polynomial and may lead to a reducible polynomial. However, choosing a reducible polynomial will result in a certain proportion of missed errors, due to the quotient ring havingzero divisors.
The advantage of choosing aprimitive polynomialas the generator for a CRC code is that the resulting code has maximal total block length in the sense that all 1-bit errors within that block length have different remainders (also calledsyndromes) and therefore, since the remainder is a linear function of the block, the code can detect all 2-bit errors within that block length. Ifr{\displaystyle r}is the degree of the primitive generator polynomial, then the maximal total block length is2r−1{\displaystyle 2^{r}-1}, and the associated code is able to detect any single-bit or double-bit errors.However, if we use the generator polynomialg(x)=p(x)(1+x){\displaystyle g(x)=p(x)(1+x)}, wherep{\displaystyle p}is a primitive polynomial of degreer−1{\displaystyle r-1}, then the maximal total block length is2r−1−1{\displaystyle 2^{r-1}-1}, and the code is able to detect single, double, triple and any odd number of errors.
A polynomialg(x){\displaystyle g(x)}that admits other factorizations may be chosen then so as to balance the maximal total blocklength with a desired error detection power. TheBCH codesare a powerful class of such polynomials. They subsume the two examples above. Regardless of the reducibility properties of a generator polynomial of degreer, if it includes the "+1" term, the code will be able to detect error patterns that are confined to a window ofrcontiguous bits. These patterns are called "error bursts".
The concept of the CRC as an error-detecting code gets complicated when an implementer or standards committee uses it to design a practical system. Here are some of the complications:
These complications mean that there are three common ways to express a polynomial as an integer: the first two, which are mirror images in binary, are the constants found in code; the third is the number found in Koopman's papers.In each case, one term is omitted.So the polynomialx4+x+1{\displaystyle x^{4}+x+1}may be transcribed as:
In the table below they are shown as:
CRCs inproprietary protocolsmight beobfuscatedby using a non-trivial initial value and a final XOR, but these techniques do not add cryptographic strength to the algorithm and can bereverse engineeredusing straightforward methods.
Numerous varieties of cyclic redundancy checks have been incorporated intotechnical standards.  By no means does one algorithm, or one of each degree, suit every purpose; Koopman and Chakravarty recommend selecting a polynomial according to the application requirements and the expected distribution of message lengths.The number of distinct CRCs in use has confused developers, a situation which authors have sought to address.There are three polynomials reported for CRC-12,twenty-two conflicting definitions of CRC-16, and seven of CRC-32.
The polynomials commonly applied are not the most efficient ones possible. Since 1993, Koopman, Castagnoli and others have surveyed the space of polynomials between 3 and 64 bits in size,finding examples that have much better performance (in terms ofHamming distancefor a given message size) than the polynomials of earlier protocols, and publishing the best of these with the aim of improving the error detection capacity of future standards.In particular,iSCSIandSCTPhave adopted one of the findings of this research, the CRC-32C (Castagnoli) polynomial.
The design of the 32-bit polynomial most commonly used by standards bodies, CRC-32-IEEE, was the result of a joint effort for theRome Laboratoryand the Air Force Electronic Systems Division by Joseph Hammond, James Brown and Shyan-Shiang Liu of theGeorgia Institute of Technologyand Kenneth Brayer of theMitre Corporation. The earliest known appearances of the 32-bit polynomial were in their 1975 publications: Technical Report 2956 by Brayer for Mitre, published in January and released for public dissemination throughDTICin August,and Hammond, Brown and Liu's report for the Rome Laboratory, published in May.Both reports contained contributions from the other team. During December 1975, Brayer and Hammond presented their work in a paper at the IEEE National Telecommunications Conference: the IEEE CRC-32 polynomial is the generating polynomial of aHamming codeand was selected for its error detection performance.Even so, the Castagnoli CRC-32C polynomial used in iSCSI or SCTP matches its performance on messages from 58 bits to 131 kbits, and outperforms it in several size ranges including the two most common sizes of Internet packet.TheITU-TG.hnstandard also uses CRC-32C to detect errors in the payload (although it uses CRC-16-CCITT forPHY headers).
CRC-32C computation is implemented in hardware as an operation (CRC32) ofSSE4.2instruction set, first introduced inIntelprocessors'Nehalemmicroarchitecture.ARMAArch64architecture also provides hardware acceleration for both CRC-32 and CRC-32C operations.
The table below lists only the polynomials of the various algorithms in use. Variations of a particular protocol can impose pre-inversion, post-inversion and reversed bit ordering as described above. For example, the CRC32 used in Gzip and Bzip2 use the same polynomial, but Gzip employs reversed bit ordering, while Bzip2 does not.Note that even parity polynomials inGF(2)with degree greater than 1 are never primitive. Even parity polynomial marked as primitive in this table represent a primitive polynomial multiplied by(x+1){\displaystyle \left(x+1\right)}. The most significant bit of a polynomial is always 1, and is not shown in the hex representations.