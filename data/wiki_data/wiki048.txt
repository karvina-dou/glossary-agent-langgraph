HTTP(Hypertext Transfer Protocol) is anapplication layerprotocol in theInternet protocol suitemodel for distributed, collaborative,hypermediainformation systems.HTTP is the foundation of data communication for theWorld Wide Web, wherehypertextdocuments includehyperlinksto other resources that the user can easily access, for example by amouseclick or by tapping the screen in aweb browser.
Development of HTTP was initiated byTim Berners-LeeatCERNin 1989 and summarized in a simple document describing the behavior of a client and a server using the first HTTP version, named 0.9.That version was subsequently developed, eventually becoming the public 1.0.
Development of early HTTPRequests for Comments(RFCs) started a few years later in a coordinated effort by theInternet Engineering Task Force(IETF) and theWorld Wide Web Consortium(W3C), with work later moving to the IETF.
HTTP/1 was finalized and fully documented (as version 1.0) in 1996.It evolved (as version 1.1) in 1997 and then its specifications were updated in 1999, 2014, and 2022.Its secure variant namedHTTPSis used by more than 85% of websites.
HTTP/2, published in 2015, provides a more efficient expression of HTTP's semantics "on the wire". As of August 2024,it is supported by 66.2% of websites(35.3% HTTP/2 + 30.9% HTTP/3 with backwards compatibility) and supported by almost all web browsers (over 98% of users).It is also supported by major web servers overTransport Layer Security(TLS) using anApplication-Layer Protocol Negotiation(ALPN) extensionwhereTLS 1.2or newer is required.
HTTP/3, the successor to HTTP/2, was published in 2022.As of February 2024,it is now used on 30.9% of websitesand is supported by most web browsers, i.e. (at least partially) supported by 97% of users.HTTP/3 usesQUICinstead ofTCPfor the underlying transport protocol. Like HTTP/2, it does not obsolete previous major versions of the protocol. Support for HTTP/3 was added toCloudflareandGoogle Chromefirst,and is also enabled inFirefox.HTTP/3 has lower latency for real-world web pages, if enabled on the server, and loads faster than with HTTP/2, in some cases over three times faster than HTTP/1.1 (which is still commonly only enabled).
HTTP functions as arequest–responseprotocol in theclient–server model. Aweb browser, for example, may be theclientwhereas aprocess, namedweb server, running on a computerhostingone or morewebsitesmay be theserver. The client submits an HTTPrequestmessage to the server. The server, which providesresourcessuch asHTMLfiles and other content or performs other functions on behalf of the client, returns aresponsemessage to the client. The response contains completion status information about the request and may also contain requested content in its message body.
A web browser is an example of auser agent(UA). Other types of user agent include the indexing software used by search providers (web crawlers),voice browsers,mobile apps, and othersoftwarethat accesses, consumes, or displays web content.
HTTP is designed to permit intermediate network elements to improve or enable communications between clients and servers. High-traffic websites often benefit fromweb cacheservers that deliver content on behalf ofupstream serversto improve response time. Web browsers cache previously accessed web resources and reuse them, whenever possible, to reduce network traffic. HTTPproxy serversatprivate networkboundaries can facilitate communication for clients without a globally routable address, by relaying messages with external servers.
To allow intermediate HTTP nodes (proxy servers, web caches, etc.) to accomplish their functions, some of theHTTP headers(found in HTTP requests/responses) are managedhop-by-hopwhereas other HTTP headers are managedend-to-end(managed only by the source client and by the target web server).
HTTP is anapplication layerprotocol designed within the framework of theInternet protocol suite. Its definition presumes an underlying and reliabletransport layerprotocol.InHTTP/3, theTransmission Control Protocol(TCP) is no longer used, but the older versions are still more used and they most commonly use TCP. They have also been adapted to use unreliable protocols such as theUser Datagram Protocol(UDP), which HTTP/3 also (indirectly) always builds on, for example inHTTPUandSimple Service Discovery Protocol(SSDP).
HTTP resourcesare identified and located on the network byUniform Resource Locators(URLs), using theUniform Resource Identifiers(URIs) schemeshttpandhttps. As defined inRFC3986, URIs are encoded ashyperlinksinHTMLdocuments, so as to form interlinkedhypertextdocuments.
In HTTP/1.0 a separate TCPconnectionto the same server is made for every resource request.
In HTTP/1.1 instead a TCP connection can be reused to make multiple resource requests (i.e. of HTML pages, frames, images,scripts,stylesheets, etc.).
HTTP/1.1 communications therefore experience lesslatencyas the establishment of TCP connections presents considerable overhead, especially under high traffic conditions.
HTTP/2is a revision of previous HTTP/1.1 in order to maintain the same client–server model and the same protocol methods but with these differences in order:
HTTP/2 communications therefore experience much less latency and, in most cases, even higher speeds than HTTP/1.1 communications.
HTTP/3is a revision of previous HTTP/2 in order to useQUIC+ UDP transport protocols instead of TCP. Before that version, TCP/IP connections were used; but now, only the IP layer is used (which UDP, like TCP, builds on). This slightly improves the average speed of communications and to avoid the occasional (very rare) problem of TCP connectioncongestionthat can temporarily block or slow down the data flow of all its streams (another form of "head of line blocking").
The termhypertextwas coined byTed Nelsonin 1965 in theXanadu Project, which was in turn inspired byVannevar Bush's 1930s vision of the microfilm-based information retrieval and management "memex" system described in his 1945 essay "As We May Think".Tim Berners-Leeand his team atCERNare credited with inventing the original HTTP, along with HTML and the associated technology for aweb serverand a clientuser interfacecalledweb browser. Berners-Lee designed HTTP in order to help with the adoption of his other idea: the "WorldWideWeb" project, which was first proposed in 1989, now known as theWorld Wide Web.
The first web serverwent live in 1990.The protocol used had only one method, namely GET, which would request a page from a server.The response from the server was always an HTML page.
In 1991, the first documented official version of HTTP was written as a plain document, less than 700 words long, and this version was named HTTP/0.9, which supported only GET method, allowing clients to only retrieve HTML documents from the server, but not supporting any other file formats or information upload.
Since 1992, a new document was written to specify the evolution of the basic protocol towards its next full version. It supported both the simple request method of the 0.9 version and the full GET request that included the client HTTP version. This was the first of the many unofficial HTTP/1.0 drafts that preceded the final work on HTTP/1.0.
After having decided that new features of HTTP protocol were required and that they had to be fully documented as officialRFCs, in early 1995 the HTTP Working Group (HTTP WG, led byDave Raggett) was constituted with the aim to standardize and expand the protocol with extended operations, extended negotiation, richer meta-information, tied with a security protocol which became more efficient by adding additional methods andheader fields.
The HTTP WG planned to revise and publish new versions of the protocol as HTTP/1.0 and HTTP/1.1 within 1995, but, because of the many revisions, that timeline lasted much more than one year.
The HTTP WG planned also to specify a far future version of HTTP called HTTP-NG (HTTP Next Generation) that would have solved all remaining problems, of previous versions, related to performances, low latency responses, etc. but this work started only a few years later and it was never completed.
In May 1996,RFC1945was published as a final HTTP/1.0 revision of what had been used in previous 4 years as a pre-standard HTTP/1.0-draft which was already used by many web browsers and web servers.
In early 1996 developers started to even include unofficial extensions of the HTTP/1.0 protocol (i.e. keep-alive connections, etc.) into their products by using drafts of the upcoming HTTP/1.1 specifications.
Since early 1996, major web browsers and web server developers also started to implement new features specified by pre-standard HTTP/1.1 drafts specifications.  End-user adoption of the new versions of browsers and servers was rapid. In March 1996, one web hosting company reported that over 40% of browsers in use on the Internet used the new HTTP/1.1 header "Host" to enablevirtual hosting, and that by June 1996, 65% of all browsers accessing their servers were pre-standard HTTP/1.1 compliant.
In January 1997,RFC2068was officially released as HTTP/1.1 specifications.
In June 1999,RFC2616was released to include all improvements and updates based on previous (obsolete) HTTP/1.1 specifications.
Resuming the old 1995 plan of previous HTTP Working Group, in 1997 anHTTP-NG Working Groupwas formed to develop a new HTTP protocol named HTTP-NG (HTTP New Generation).  A few proposals / drafts were produced for the new protocol to usemultiplexingof HTTP transactions inside a single TCP/IP connection, but in 1999, the group stopped its activity passing the technical problems to IETF.
In 2007, the IETFHTTP Working Group(HTTP WG bis or HTTPbis) was restarted firstly to revise and clarify previous HTTP/1.1 specifications and secondly to write and refine future HTTP/2 specifications (named httpbis).
In 2009,Google, a private company, announced that it had developed and tested a new HTTP binary protocol namedSPDY. The implicit aim was to greatly speed up web traffic (specially between future web browsers and its servers).
SPDY was indeed much faster than HTTP/1.1 in many tests and so it was quickly adopted byChromiumand then by other major web browsers.
Some of the ideas about multiplexing HTTP streams over a single TCP/IP connection were taken from various sources, including the work of W3C HTTP-NG Working Group.
In January–March 2012, HTTP Working Group (HTTPbis) announced the need to start to focus on a new HTTP/2 protocol (while finishing the revision of HTTP/1.1 specifications), maybe taking in consideration ideas and work done for SPDY.
After a few months about what to do to develop a new version of HTTP, it was decided to derive it from SPDY.
In May 2015,HTTP/2was published asRFC7540and quickly adopted by all web browsers already supporting SPDY and more slowly by web servers.
In June 2014, the HTTP Working Group released an updated six-part HTTP/1.1 specification obsoletingRFC2616:
InRFC7230Appendix-A, HTTP/0.9 was deprecated for servers supporting HTTP/1.1 version (and higher):
Since HTTP/0.9 did not support header fields in a request, there is no mechanism for it to support name-based virtual hosts (selection of resource by inspection of the Host header field).Any server that implements name-based virtual hosts ought to disable support for HTTP/0.9.  Most requests that appear to be HTTP/0.9 are, in fact, badly constructed HTTP/1.x requests caused by a client failing to properly encode the request-target.
Since 2016 many product managers and developers of user agents (browsers, etc.) and web servers have begun planning to gradually deprecate and dismiss support for HTTP/0.9 protocol, mainly for the following reasons:
In 2020, the first draftsHTTP/3were published and major web browsers and web servers started to adopt it.
On 6 June 2022, IETF standardized HTTP/3 asRFC9114.
In June 2022, a batch of RFCs was published, deprecating many of the previous documents and introducing a few minor changes and a refactoring of HTTP semantics description into a separate document.
HTTP is astatelessapplication-level protocol and it requires a reliable network transport connection to exchange data between client and server.In HTTP implementations,TCP/IPconnections are used usingwell-known ports(typicallyport 80if the connection is unencrypted or port 443 if the connection is encrypted, see alsoList of TCP and UDP port numbers).In HTTP/2, a TCP/IP connection plus multiple protocol channels are used. In HTTP/3, the application transport protocolQUICover UDP is used.
Data is exchanged through a sequence ofrequest–response messageswhich are exchanged by asession layertransport connection.An HTTP client initially tries to connect to a server establishing a connection (real or virtual). An HTTP(S) server listening on that port accepts the connection and then waits for a client's request message. The client sends its HTTP request message. Upon receiving the request the server sends back an HTTP response message, which includes header(s) plus a body if it is required. The body of this response message is typically the requested resource, although an error message or other information may also be returned. At any time (for many reasons) client or server can close the connection. Closing a connection is usually advertised in advance by using one or more HTTP headers in the last request/response message sent to server or client.
InHTTP/0.9, the TCP/IP connection is always closed after server response has been sent, so it is never persistent.
InHTTP/1.0, as stated in RFC 1945, the TCP/IP connection should always be closed by server after a response has been sent.
InHTTP/1.1a keep-alive-mechanism was officially introduced so that a connection could be reused for more than one request/response. Such persistent connections reduce requestlatencyperceptibly because the client does not need to re-negotiate theTCP 3-Way-Handshake connectionafter the first request has been sent. Another positive side effect is that, in general, the connection becomes faster with time due to TCP'sslow-start-mechanism.
HTTP/1.1added alsoHTTP pipeliningin order to further reduce lag time when using persistent connections by allowing clients to send multiple requests before waiting for each response.  This optimization was never considered really safe because a few web servers and manyproxy servers, specially transparent proxy servers placed in Internet /Intranetsbetween clients and servers, did not handle pipelined requests properly (they served only the first request discarding the others, they closed the connection because they saw more data after the first request or some proxies even returned responses out of order etc.).  Because of this, only HEAD and some GET requests (i.e. limited to real file requests and so withURLswithout query string used as a command, etc.) could be pipelined in asafeandidempotentmode.  After many years of struggling with the problems introduced by enabling pipelining, this feature was first disabled and then removed from most browsers also because of the announced adoption of HTTP/2.
HTTP/2extended the usage of persistent connections by multiplexing many concurrent requests/responses through a single TCP/IP connection.
HTTP/3does not use TCP/IP connections but QUIC + UDP (see also:technical overview).
HTTP provides multiple authentication schemes such asbasic access authenticationanddigest access authenticationwhich operate via a challenge–response mechanism whereby the server identifies and issues a challenge before serving the requested content.
HTTP provides a general framework for access control and authentication, via an extensible set of challenge–response authentication schemes, which can be used by a server to challenge a client request and by a client to provide authentication information.
The authentication mechanisms described above belong to the HTTP protocol and are managed by client and server HTTP software (if configured to require authentication before allowing client access to one or more web resources), and not by the web applications usinga web application session.
The HTTP Authentication specification also provides an arbitrary, implementation-specific construct for further dividing resources common to a given rootURI. The realm value string, if present, is combined with the canonical root URI to form the protection space component of the challenge. This in effect allows the server to define separate authentication scopes under one root URI.
HTTP is astateless protocol. A stateless protocol does not require the web server to retain information or status about each user for the duration of multiple requests.
Someweb applicationsneed to manage user sessions, so they implement states, orserver side sessions, using for instanceHTTP cookiesor hiddenvariableswithinweb forms.
To start an application user session, an interactiveauthenticationvia web applicationloginmust be performed. To stop a user session alogoutoperation must be requested by user.  These kind of operations do not useHTTP authenticationbut a custom managed web application authentication.
Request messages are sent by a client to a target server.
A client sendsrequest messagesto the server, which consist of:
In the HTTP/1.1 protocol, all header fields exceptHost: hostnameare optional.
A request line containing only the path name is accepted by servers to maintain compatibility with HTTP clients before the HTTP/1.0 specification inRFC1945.
HTTP defines methods (sometimes referred to asverbs, but nowhere in the specification does it mentionverb) to indicate the desired action to be performed on the identified resource. What this resource represents, whether pre-existing data or data that is generated dynamically, depends on the implementation of the server. Often, the resource corresponds to a file or the output of an executable residing on the server. The HTTP/1.0 specificationdefined the GET, HEAD, and POST methods as well as listing the PUT, DELETE, LINK and UNLINK methods under additional methods.  However, the HTTP/1.1 specificationformally defined and added five new methods: PUT, DELETE, CONNECT, OPTIONS, and TRACE. Any client can use any method and the server can be configured to support any combination of methods. If a method is unknown to an intermediate, it will be treated as an unsafe andnon-idempotentmethod. There is no limit to the number of methods that can be defined, which allows for future methods to be specified without breaking existing infrastructure. For example,WebDAVdefined seven new methods andRFC5789specified thePATCHmethod.
Method names are case sensitive.This is in contrast to HTTP header field names which are case-insensitive.
All general-purpose web servers are required to implement at least the GET and HEAD methods, and all other methods are considered optional by the specification.
A request method issafeif a request with that method has no intended effect on the server. The methods GET, HEAD, OPTIONS, and TRACE are defined as safe. In other words, safe methods are intended to beread-only. Safe methods can still haveside effectsnot seen by the client, such as appending request information to alog fileor charging anadvertising account.
In contrast, the methods POST, PUT, DELETE, CONNECT, and PATCH are not safe. They may modify the state of the server or have other effects such as sending anemail. Such methods are therefore not usually used by conformingweb robotsor web crawlers; some that do not conform tend to make requests without regard to context or consequences.
Despite the prescribed safety of GET requests, in practice their handling by the server is not technically limited in any way. Careless or deliberately irregular programming can allow GET requests to cause non-trivial changes on the server. This is discouraged because of the problems which can occur whenweb caching,search engines, and other automated agents make unintended changes on the server. For example, a website might allow deletion of a resource through a URL such ashttps://example.com/article/1234/delete, which, if arbitrarily fetched, even using GET, would simply delete the article.A properly coded website would require a DELETE or POST method for this action, which non-malicious bots would not make.
One example of this occurring in practice was during the short-livedGoogle Web Acceleratorbeta, which prefetched arbitrary URLs on the page a user was viewing, causing records to be automatically altered or deleteden masse. Thebetawas suspended only weeks after its first release, following widespread criticism.
A request method isidempotentif multiple identical requests with that method have the same effect as a single such request. The methods PUT and DELETE, and safe methods are defined as idempotent. Safe methods are trivially idempotent, since they are intended to have no effect on the server whatsoever; the PUT and DELETE methods, meanwhile, are idempotent since successive identical requests will be ignored. A website might, for instance, set up a PUT endpoint to modify a user's recorded email address. If this endpoint is configured correctly, any requests which ask to change a user's email address to the same email address which is already recorded—e.g. duplicate requests following a successful request—will have no effect. Similarly, a request to DELETE a certain user will have no effect if that user has already been deleted.
In contrast, the methods POST, CONNECT, and PATCH are not necessarily idempotent, and therefore sending an identical POST request multiple times may further modify the state of the server or have further effects, such as sending multipleemails. In some cases this is the desired effect, but in other cases it may occur accidentally. A user might, for example, inadvertently send multiple POST requests by clicking a button again if they were not given clear feedback that the first click was being processed. Whileweb browsersmay showalert dialog boxesto warn users in some cases where reloading a page may re-submit a POST request, it is generally up to the web application to handle cases where a POST request should not be submitted more than once.
Note that whether or not a method is idempotent is not enforced by the protocol or web server. It is perfectly possible to write a web application in which (for example) a database insert or other non-idempotent action is triggered by a GET or other request. To do so against recommendations, however, may result in undesirable consequences, if auser agentassumes that repeating the same request is safe when it is not.
A request method iscacheableif responses to requests with that method may be stored for future reuse. The methods GET, HEAD, and POST are defined as cacheable.
In contrast, the methods PUT, DELETE, CONNECT, OPTIONS, TRACE, and PATCH are not cacheable.
Request header fields allow the client to pass additional information beyond the request line, acting as request modifiers (similarly to the parameters of a procedure). They give information about the client, about the target resource, or about the expected handling of the request.
A response message is sent by a server to a client as a reply to its former request message.
A server sendsresponse messagesto the client, which consist of:
In HTTP/1.0 and since, the first line of the HTTP response is called thestatus lineand includes a numericstatus code(such as "404") and a textualreason phrase(such as "Not Found"). The response status code is a three-digit integer code representing the result of the server's attempt to understand and satisfy the client's corresponding request. The way the client handles the response depends primarily on the status code, and secondarily on the other response header fields. Clients may not understand all registered status codes but they must understand their class (given by the first digit of the status code) and treat an unrecognized status code as being equivalent to the x00 status code of that class.
The standardreason phrasesare only recommendations, and can be replaced with "local equivalents" at theweb developer's discretion. If the status code indicated a problem, the user agent might display thereason phraseto the user to provide further information about the nature of the problem. The standard also allows the user agent to attempt to interpret thereason phrase, though this might be unwise since the standard explicitly specifies that status codes are machine-readable andreason phrasesare human-readable.
The first digit of the status code defines its class:
The response header fields allow the server to pass additional information beyond the status line, acting as response modifiers. They give information about the server or about further access to the target resource or related resources.
Each response header field has a defined meaning which can be further refined by the semantics of the request method or response status code.
Below is a sample HTTP transaction between an HTTP/1.1 client and an HTTP/1.1 server running onwww.example.com, port 80.
A client request (consisting in this case of the request line and a few headers that can be reduced to only the"Host: hostname"header) is followed by a blank line, so that the request ends with a double end of line, each in the form of acarriage returnfollowed by aline feed. The"Host: hostname"header value distinguishes between variousDNSnames sharing a singleIP address, allowing name-basedvirtual hosting. While optional in HTTP/1.0, it is mandatory in HTTP/1.1. (A "/" (slash) will usually fetch a/index.htmlfile if there is one.)
TheETag(entity tag) header field is used to determine if a cached version of the requested resource is identical to the current version of the resource on the server."Content-Type"specifies theInternet media typeof the data conveyed by the HTTP message, while"Content-Length"indicates its length in bytes. The HTTP/1.1webserverpublishes its ability to respond to requests for certain byte ranges of the document by setting the field"Accept-Ranges: bytes". This is useful, if the client needs to have only certain portionsof a resource sent by the server, which is calledbyte serving. When"Connection: close"is sent, it means that theweb serverwill close theTCPconnection immediately after the end of the transfer of this response.
Most of the header lines are optional but some are mandatory. When header"Content-Length: number"is missing in a response with an entity body then this should be considered an error in HTTP/1.0 but it may not be an error in HTTP/1.1 if header"Transfer-Encoding: chunked"is present. Chunked transfer encoding uses a chunk size of 0 to mark the end of the content. Some old implementations of HTTP/1.0 omitted the header"Content-Length"when the length of the body entity was not known at the beginning of the response and so the transfer of data to client continued until server closed the socket.
A"Content-Encoding:gzip"can be used to inform the client that the body entity part of the transmitted data is compressed by gzip algorithm.
The most popular way of establishing an encrypted HTTP connection isHTTPS.Two other methods for establishing an encrypted HTTP connection also exist:Secure Hypertext Transfer Protocol, and using theHTTP/1.1 Upgrade headerto specify an upgrade to TLS. Browser support for these two is, however, nearly non-existent.