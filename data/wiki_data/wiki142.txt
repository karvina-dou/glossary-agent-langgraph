Incomputing, avirtual machine(VM) is thevirtualizationoremulationof acomputer system.  Virtual machines are based oncomputer architecturesand provide the functionality of a physical computer. Their implementations may involve specialized hardware, software, or a combination of the two.
Virtual machines differ and are organized by their function, shown here:
Some virtual machine emulators, such asQEMUandvideo game console emulators, are designed to also emulate (or "virtually imitate") different system architectures, thus allowing execution of software applications and operating systems written for another CPU or architecture.OS-level virtualizationallows the resources of a computer to be partitioned via thekernel. The terms are not universally interchangeable.
A "virtual machine" was originally defined byPopek and Goldbergas "an efficient, isolated duplicate of a real computer machine."Current use includes virtual machines that have no direct correspondence to any real hardware.The physical, "real-world" hardware running the VM is generally referred to as the 'host', and the virtual machine emulated on that machine is generally referred to as the 'guest'. A host can emulate several guests, each of which can emulate differentoperating systemsand hardware platforms.
The desire to run multiple operating systems was the initial motive for virtual machines, so as to allow time-sharing among several single-tasking operating systems. In some respects, a system virtual machine can be considered a generalization of the concept ofvirtual memorythat historically preceded it. IBM'sCP/CMS, the first systems to allowfull virtualization, implementedtime sharingby providing each user with a single-user operating system, theConversational Monitor System(CMS). Unlike virtual memory, a system virtual machine entitled the user to write privileged instructions in their code. This approach had certain advantages, such as adding input/output devices not allowed by the standard system.
As technology evolves virtual memory for purposes of virtualization, new systems ofmemory overcommitmentmay be applied to manage memory sharing among multiple virtual machines on one computer operating system. It may be possible to sharememory pagesthat have identical contents among multiple virtual machines that run on the same physical machine, what may result in mapping them to the same physical page by a technique termedkernel same-page merging(KSM). This is especially useful for read-only pages, such as those holding code segments, which is the case for multiple virtual machines running the same or similar software, software libraries, web servers,middlewarecomponents, etc. The guest operating systems do not need to be compliant with the host hardware, thus making it possible to run different operating systems on the same computer (e.g.,Windows,Linux, or prior versions of an operating system) to support future software.
The use of virtual machines to support separate guest operating systems is popular in regard toembedded systems. A typical use would be to run areal-time operating systemsimultaneously with a preferred complex operating system, such as Linux or Windows. Another use would be for novel and unproven software still in the developmental stage, so it runs inside asandbox. Virtual machines have other advantages for operating system development and may include improved debugging access and faster reboots.
Multiple VMs running their own guest operating system are frequently engaged for server consolidation.
A process VM, sometimes called anapplication virtual machine, orManaged Runtime Environment(MRE), runs as a normal application inside a host OS and supports a single process. It is created when that process is started and destroyed when it exits. Its purpose is to provide aplatform-independent programming environment that abstracts away details of the underlying hardware or operating system and allows a program to execute in the same way on any platform.
A process VM provides a high-level abstraction –  that of ahigh-level programming language(compared to the low-level ISA abstraction of the system VM). Process VMs are implemented using aninterpreter; performance comparable to compiled programming languages can be achieved by the use ofjust-in-time compilation.
This type of VM has become popular with theJava programming language, which is implemented using theJava virtual machine. Other examples include theParrot virtual machineand the.NET Framework, which runs on a VM called theCommon Language Runtime. All of them can serve as anabstraction layerfor any computer language.
A special case of process VMs are systems that abstract over the communication mechanisms of a (potentially heterogeneous)computer cluster. Such a VM does not consist of a single process, but one process per physical machine in the cluster. They are designed to ease the task of programming concurrent applications by letting the programmer focus on algorithms rather than the communication mechanisms provided by the interconnect and the OS. They do not hide the fact that communication takes place, and as such do not attempt to present the cluster as a single machine.
Unlike other process VMs, these systems do not provide a specific programming language, but are embedded in an existing language; typically such a system provides bindings for several languages (e.g.,CandFortran).Examples areParallel Virtual Machine(PVM) andMessage Passing Interface(MPI).
Both system virtual machines and process virtual machines date to the 1960s and remain areas of active development.
System virtual machinesgrew out oftime-sharing, as notably implemented in theCompatible Time-Sharing System(CTSS). Time-sharing allowed multiple users to use a computerconcurrently: each program appeared to have full access to the machine, but only one program was executed at the time, with the system switching between programs in time slices, saving and restoring state each time. This evolved into virtual machines, notably via IBM's research systems: theM44/44X, which usedpartial virtualization, and theCP-40andSIMMON, which usedfull virtualization, and were early examples ofhypervisors. The first widely available virtual machine architecture was theCP-67/CMS (seeHistory of CP/CMSfor details). An important distinction was between using multiple virtual machines on one host system for time-sharing, as in M44/44X and CP-40, and using one virtual machine on a host system for prototyping, as in SIMMON.Emulators, with hardware emulation of earlier systems for compatibility, date back to theIBM System/360in 1963,while the software emulation (then-called "simulation") predates it.
Process virtual machinesarose originally as abstract platforms for anintermediate languageused as theintermediate representationof a program by acompiler; early examples date to around 1964 with theMETA IIcompiler-writing system using it for both syntax description and target code generation. A notable 1966 example was theO-code machine, a virtual machine that executesO-code(object code) emitted by thefront endof theBCPLcompiler. This abstraction allowed the compiler to be easily ported to a new architecture by implementing a newback endthat took the existing O-code and compiled it to machine code for the underlying physical machine. TheEulerlanguage used a similar design, with the intermediate language namedP(portable).This was popularized around 1970 byPascal, notably in thePascal-Psystem (1973) andPascal-Scompiler (1975), in which it was termedp-codeand the resulting machine as ap-code machine. This has been influential, and virtual machines in this sense have been often generally called p-code machines. In addition to being an intermediate language, Pascal p-code was also executed directly by an interpreter implementing the virtual machine, notably inUCSD Pascal(1978); this influenced later interpreters, notably theJava virtual machine(JVM). Another early example wasSNOBOL4(1967), which was written in the SNOBOL Implementation Language (SIL), an assembly language for a virtual machine, which was then targeted to physical machines by transpiling to their native assembler via amacro assembler.Macros have since fallen out of favor, however, so this approach has been less influential. Process virtual machines were a popular approach to implementing early microcomputer software, includingTiny BASICand adventure games, from one-off implementations such asPyramid 2000to a general-purpose engine likeInfocom'sz-machine, whichGraham Nelsonargues is "possibly the most portable virtual machine ever created".
Significant advances occurred in the implementation ofSmalltalk-80,particularly the Deutsch/Schiffmann implementationwhich pushedjust-in-time (JIT) compilationforward as an implementation approach that uses process virtual machine.Later notable Smalltalk VMs wereVisualWorks, theSqueak Virtual Machine,andStrongtalk.A related language that produced a lot of virtual machine innovation was theSelfprogramming language,which pioneeredadaptive optimizationandgenerational garbage collection. These techniques proved commercially successful in 1999 in theHotSpotJava virtual machine.Other innovations include a register-based virtual machine, to better match the underlying hardware, rather than a stack-based virtual machine, which is a closer match for the programming language; in 1995, this was pioneered by theDis virtual machinefor theLimbolanguage.
In full virtualization, the virtual machine simulates enough hardware to allow an unmodified "guest" OS (one designed for the sameinstruction set) to be run in isolation. This approach was pioneered in 1966 with the IBMCP-40andCP-67, predecessors of theVMfamily.
Examples outside the mainframe field includeParallels Workstation,Parallels Desktop for Mac,VirtualBox,Virtual Iron,Oracle VM,Virtual PC,Virtual Server,Hyper-V,VMware Fusion,VMware Workstation,VMware Server(discontinued, formerly called GSX Server),VMware ESXi,QEMU,Adeos, Mac-on-Linux, Win4BSD,Win4Lin Pro, andEgeneravBlade  technology.
In hardware-assisted virtualization, the hardware provides architectural support that facilitates building a virtual machine monitor and allows guest OSes to be run in isolation.Hardware-assisted virtualization was first introduced on the IBM System/370 in 1972, for use withVM/370, the first virtual machine operating system offered by IBM as an official product.
In 2005 and 2006,IntelandAMDprovided additional hardware to support virtualization. Sun Microsystems (nowOracle Corporation) added similar features in theirUltraSPARC T-Seriesprocessors in 2005.  Examples of virtualization platforms adapted to such hardware includeKVM,VMware Workstation,VMware Fusion,Hyper-V,Windows Virtual PC,Xen,Parallels Desktop for Mac,Oracle VM Server for SPARC,VirtualBoxandParallels Workstation.
In 2006, first-generation 32- and 64-bit x86 hardware support was found to rarely offer performance advantages over software virtualization.
In OS-level virtualization, a physical server is virtualized at the operating system level, enabling multiple isolated and secure virtualized servers to run on a single physical server.  The "guest" operating system environments share the same running instance of the operating system as the host system.  Thus, the sameoperating system kernelis also used to implement the "guest" environments, and applications running in a given "guest" environment view it as a stand-alone system. The pioneer implementation wasFreeBSD jails; other examples includeDocker,Solaris Containers,OpenVZ,Linux-VServer,LXC, AIXWorkload Partitions, Parallels Virtuozzo Containers, and iCore Virtual Accounts.
Asnapshotis a state of a virtual machine, and generally its storage devices, at an exact point in time. A snapshot enables the virtual machine's state at the time of the snapshot to be restored later, effectively undoing any changes that occurred afterwards. This capability is useful as abackuptechnique, for example, prior to performing a risky operation.
Virtual machines frequently usevirtual disksfor their storage; in a very simple example, a 10-gigabytehard disk driveis simulated with a 10-gigabyteflat file. Any requests by the VM for a location on its physical disk are transparently translated into an operation on the corresponding file. Once such a translation layer is present, however, it is possible to intercept the operations and send them to different files, depending on various criteria. Every time a snapshot is taken, a new file is created, and used as an overlay for its predecessors. New data is written to the topmost overlay; reading existing data, however, needs the overlay hierarchy to be scanned, resulting in accessing the most recent version. Thus, the entire stack of snapshots is virtually a single coherent disk; in that sense, creating snapshots works similarly to theincremental backuptechnique.
Other components of a virtual machine can also be included in a snapshot, such as the contents of itsrandom-access memory(RAM),BIOSsettings, or its configuration settings.  "Save state" feature invideo game console emulatorsis an example of such snapshots.
Restoring a snapshot consists of discarding or disregarding all overlay layers that are added after that snapshot, and directing all new changes to a new overlay.
The snapshots described above can be moved to another host machine with its own hypervisor; when the VM is temporarily stopped, snapshotted, moved, and then resumed on the new host, this is known as migration.  If the older snapshots are kept in sync regularly, this operation can be quite fast, and allow the VM to provide uninterrupted service while its prior physical host is, for example, taken down for physical maintenance.
Similar to the migration mechanism described above, failover allows the VM to continue operations if the host fails. Generally it occurs if the migration has stopped working. However, in this case, the VM continues operation from thelast-knowncoherent state, rather than thecurrentstate, based on whatever materials the backup server was last provided with.
Nested virtualization refers to the ability of running a virtual machine within another, having this general concept extendable to an arbitrary depth.  In other words, nested virtualization refers to running one or morehypervisorsinside another hypervisor. The nature of a nested guest virtual machine does not need to be homogeneous with its host virtual machine; for example,application virtualizationcan be deployed within a virtual machine created by usinghardware virtualization.
Nested virtualization becomes more necessary as widespread operating systems gain built-in hypervisor functionality, which in a virtualized environment can be used only if the surrounding hypervisor supports nested virtualization; for example,Windows 7is capable of runningWindows XPapplications inside a built-in virtual machine.  Furthermore, moving already existing virtualized environments into a cloud, following theInfrastructure as a Service(IaaS) approach, is much more complicated if the destination IaaS platform does not support nested virtualization.
The way nested virtualization can be implemented on a particularcomputer architecturedepends on supportedhardware-assisted virtualizationcapabilities.  If a particular architecture does not provide hardware support required for nested virtualization, various software techniques are employed to enable it.Over time, more architectures gain required hardware support; for example, since theHaswellmicroarchitecture (announced in 2013), Intel started to includeVMCS shadowingas a technology that accelerates nested virtualization.